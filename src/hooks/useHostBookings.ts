import { useState, useCallback } from 'react';
import { supabase } from '../services/supabase';
import { useAuth } from '../services/AuthContext';
import { useEmailService } from './useEmailService';

export interface HostBooking {
  id: string;
  property_id: string;
  guest_id: string;
  check_in_date: string;
  check_out_date: string;
  guests_count: number;
  adults_count: number;
  children_count: number;
  infants_count: number;
  total_price: number;
  status: 'pending' | 'confirmed' | 'cancelled' | 'completed';
  message_to_host?: string;
  special_requests?: string;
  discount_applied?: boolean;
  discount_amount?: number;
  original_total?: number;
  created_at: string;
  updated_at: string;
  properties?: {
    id: string;
    title: string;
    price_per_night: number;
    images: string[];
    cities?: {
      name: string;
      region: string;
    };
  };
  guest_profile?: {
    first_name: string;
    last_name: string;
    email: string;
    phone?: string;
  };
}

export const useHostBookings = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { user } = useAuth();
  const { 
    sendBookingRequest, 
    sendBookingRequestSent, 
    sendBookingResponse, 
    sendBookingConfirmed, 
    sendBookingConfirmedHost,
    sendBookingCancelled,
    sendBookingCancelledHost 
  } = useEmailService();

  const getHostBookings = useCallback(async (): Promise<HostBooking[]> => {
    if (!user) {
      setError('Vous devez √™tre connect√©');
      return [];
    }

    setLoading(true);
    setError(null);

    try {
      console.log('üîÑ [useHostBookings] Chargement des r√©servations h√¥te pour:', user.id);
      
      const { data, error } = await supabase
        .from('bookings')
        .select(`
          *,
          properties!inner(
            id,
            title,
            price_per_night,
            images,
            host_id,
            cities(
              name,
              region
            )
          ),
          guest_profile:profiles!bookings_guest_id_fkey(
            first_name,
            last_name,
            email,
            phone
          )
        `)
        .eq('properties.host_id', user.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('‚ùå [useHostBookings] Erreur lors du chargement:', error);
        setError('Erreur lors du chargement des r√©servations');
        return [];
      }

      console.log('‚úÖ [useHostBookings] R√©servations charg√©es:', data?.length || 0);
      return data || [];
    } catch (err) {
      console.error('‚ùå [useHostBookings] Erreur inattendue:', err);
      setError('Erreur lors du chargement des r√©servations');
      return [];
    } finally {
      setLoading(false);
    }
  }, [user]);

  const updateBookingStatus = useCallback(async (bookingId: string, status: 'confirmed' | 'cancelled') => {
    if (!user) {
      setError('Vous devez √™tre connect√©');
      return { success: false };
    }

    setLoading(true);
    setError(null);

    try {
      console.log('üîÑ [useHostBookings] Mise √† jour statut r√©servation:', bookingId, 'vers:', status);

      // R√©cup√©rer les d√©tails de la r√©servation pour l'email
      const { data: bookingData, error: fetchError } = await supabase
        .from('bookings')
        .select(`
          *,
          properties!inner(
            id,
            title,
            host_id,
            cities(name)
          ),
          guest_profile:profiles!bookings_guest_id_fkey(
            first_name,
            last_name,
            email
          )
        `)
        .eq('id', bookingId)
        .eq('properties.host_id', user.id)
        .single();

      if (fetchError || !bookingData) {
        console.error('‚ùå [useHostBookings] R√©servation non trouv√©e:', fetchError);
        setError('R√©servation non trouv√©e');
        return { success: false };
      }

      // Mettre √† jour le statut
      const { error: updateError } = await supabase
        .from('bookings')
        .update({ 
          status,
          updated_at: new Date().toISOString()
        })
        .eq('id', bookingId);

      if (updateError) {
        console.error('‚ùå [useHostBookings] Erreur mise √† jour:', updateError);
        setError('Erreur lors de la mise √† jour');
        return { success: false };
      }

      // Envoyer les emails selon le statut
      try {
        if (status === 'confirmed') {
          // Email de confirmation au voyageur
          await sendBookingResponse(
            bookingData.guest_profile.email,
            `${bookingData.guest_profile.first_name} ${bookingData.guest_profile.last_name}`,
            bookingData.properties.title,
            bookingData.check_in_date,
            bookingData.check_out_date,
            bookingData.guests_count,
            bookingData.total_price,
            'confirmed'
          );

          // Email de confirmation √† l'h√¥te
          await sendBookingConfirmedHost(
            user.email || '',
            `${user.user_metadata?.first_name || ''} ${user.user_metadata?.last_name || ''}`,
            `${bookingData.guest_profile.first_name} ${bookingData.guest_profile.last_name}`,
            bookingData.properties.title,
            bookingData.check_in_date,
            bookingData.check_out_date,
            bookingData.guests_count,
            bookingData.total_price
          );

          console.log('‚úÖ [useHostBookings] Emails de confirmation envoy√©s');
        } else if (status === 'cancelled') {
          // Email d'annulation au voyageur
          await sendBookingResponse(
            bookingData.guest_profile.email,
            `${bookingData.guest_profile.first_name} ${bookingData.guest_profile.last_name}`,
            bookingData.properties.title,
            bookingData.check_in_date,
            bookingData.check_out_date,
            bookingData.guests_count,
            bookingData.total_price,
            'cancelled'
          );

          // Email d'annulation √† l'h√¥te
          await sendBookingCancelledHost(
            user.email || '',
            `${user.user_metadata?.first_name || ''} ${user.user_metadata?.last_name || ''}`,
            `${bookingData.guest_profile.first_name} ${bookingData.guest_profile.last_name}`,
            bookingData.properties.title,
            bookingData.check_in_date,
            bookingData.check_out_date,
            bookingData.guests_count,
            bookingData.total_price
          );

          console.log('‚úÖ [useHostBookings] Emails d\'annulation envoy√©s');
        }
      } catch (emailError) {
        console.error('‚ùå [useHostBookings] Erreur envoi email:', emailError);
        // Ne pas faire √©chouer la mise √† jour si l'email √©choue
      }

      console.log('‚úÖ [useHostBookings] Statut mis √† jour avec succ√®s');
      return { success: true };
    } catch (err) {
      console.error('‚ùå [useHostBookings] Erreur inattendue:', err);
      setError('Erreur lors de la mise √† jour');
      return { success: false };
    } finally {
      setLoading(false);
    }
  }, [user, sendBookingResponse, sendBookingConfirmedHost, sendBookingCancelledHost]);

  return {
    getHostBookings,
    updateBookingStatus,
    loading,
    error,
  };
};
